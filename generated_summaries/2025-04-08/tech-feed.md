# Protectd: Evolving Vercel’s always-on denial-of-service mitigations - Vercel

[View on Vercel Blog](https://vercel.com/blog/protectd-evolving-vercels-always-on-denial-of-service-mitigations)

## Vercel、常に稼働するDoS対策を強化する新エンジン「Protectd」を発表

Vercelは、Webアプリケーションのセキュリティをプラットフォームの基盤として重視しており、常に稼働するDoS（サービス拒否）攻撃対策をデフォルトで提供してきました。昨年は、Vercel Firewallをリリースし、トラフィックの検査、カスタムルールの適用、プラットフォームによる防御の理解を可能にしました。

今回発表されたのは、次世代のリアルタイムセキュリティエンジン「Protectd」です。Protectdは、すべてのデプロイメントで実行され、新しいDoS攻撃に対する緩和時間を10倍以上短縮し、より高速で適応性の高い保護を提供します。

**Protectdの仕組み:**

Protectdは、トラフィック属性間の複雑な関係を継続的にマッピングし、パターンを分析して学習することで、攻撃を予測しブロックします。従来のDoS対策は、以下の4つの段階で機能していました。

1.  **Point-of-presence（PoP）での緩和:** 各リクエストは、PoPを経由してL3（ネットワーク層）とL4（トランスポート層）攻撃をブロックします。
2.  **トランスポート層の冗長性:** L4保護の第二層で、状態データを利用して、より深い検査が必要な攻撃を特定しブロックします。
3.  **インバンドアプリケーション層の緩和:** TLS終端サービスで、TLSハンドシェイクを実行し、一般的な攻撃シグネチャに対してリアルタイムで各リクエストを処理して、L7（アプリケーション層）の緩和を実行します。
4.  **アウトオブバンドアプリケーション層分析:** dos-mitigation-controllerがネットワークイベント（netlogs）を分析し、JA4フィンガープリント、User-Agent文字列、IPアドレス、リクエストパターンなどの属性を追跡します。攻撃パターンが特定されると、緩和シグネチャがすべてのTLS終端インスタンスに配布され、適用されます。

**Protectdによる改善点:**

従来のシステムは高いトラフィック量をフィルタリングし、様々なDoS攻撃を軽減していましたが、アウトオブバンド緩和では、緩和時間が20秒を超えるボトルネックがありました。Protectdは、垂直スケーリングに最適化されたストリームプロセッサであり、リアルタイムでセキュリティシグナルを検出し対応するように設計されたカスタムイベント処理ライブラリ上に構築されています。

*   **高速化:** 従来のグローバル集約設計を、エッジ集約に移行し、新しい脅威のブロック速度を10倍に高速化しました。
*   **効率性:** Golangで構築されており、14 CPUコアで毎秒約55万イベントを処理し、数百万の防御決定を実行できます。
*   **リアルタイム性:** ClickHouseは引き続き長期的なトラフィックインテリジェンスの基盤として機能し、複雑な行動シグナルを生成するのに役立ちます。Protectdは、ライブシグナルをリアルタイムで処理し、脅威を検出して軽減します。
*   **高度な学習:** トラフィック属性間の複雑な関係を継続的にマッピングし、パターンから学習します。
*   **迅速な対応:** 疑わしいパターンを特定すると、防御シグネチャを同じVercelリージョン内のイベントバスに直接プッシュし、TLSターミネーターによって迅速に適用されます。

**検証と影響:**

Protectdは、新しいルールが効果的で正確であり、影響がテストされていることを確認するための厳格なテスト検証メカニズムを備えています。

*   **シャドウモード:** 新しいフィルタは、最初にシャドウモードで実行され、疑わしいトラフィックをブロックせずにフラグを立てます。
*   **ロールアウト:** 段階的なロールアウトがサポートされており、意図しない結果を回避しながら防御を進化させることができます。
*   **バックテスト:** 過去の攻撃をスナップショットし、サンドボックス環境で新しい緩和策をテストできます。

2025年1月に本格展開が開始され、P99緩和時間は3.5秒、P50緩和時間は2.5秒、最短で0.5秒で脅威に対応できるようになりました。300万件以上のL7イベントをすでに阻止しており、他のCDNでは防げなかった攻撃も5%以上検知しています。

Vercelは、DoS脅威の進化に対応し、セキュリティを継続的に強化していく方針です。DoS攻撃に遭遇した場合は、チケットを提出することで、常に稼働する対策をより強固にすることができます。

---
# Trigger GitHub Actions with enriched deployment data from Vercel - Vercel

[View on Vercel Blog](https://vercel.com/changelog/trigger-github-actions-with-enriched-deployment-data-from-vercel)

## Vercel のデプロイデータを利用した GitHub Actions のトリガーに関する要約

Vercel は、デプロイメントイベントに応答して GitHub Actions ワークフローをトリガーする機能を強化しました。具体的には、Vercel から GitHub へ `repository_dispatch` イベントを送信し、デプロイに関する詳細なデータ（エンリッチされたデータ）を付与することで、より柔軟で費用対効果の高い CI ワークフローを実現します。

以前は、`deployment_status` イベントを使用していましたが、この方法ではペイロードが限定的で、変更内容を理解するために追加の解析や調査が必要でした。新しい `repository_dispatch` イベントでは、Vercel が完全なデプロイメントコンテキストを持つカスタム JSON ペイロードを送信するため、GitHub Actions のオーバーヘッドを削減し、CI パイプラインを効率化できます。

Vercel は、より良い体験のために `repository_dispatch` への移行を推奨しています。互換性のために、`deployment_status` イベントも引き続き機能します。

---
# Get the Index Values From forEach Loop in JSTL | Baeldung

[View on Baeldung](https://feeds.feedblitz.com/~/916326902/0/baeldung~Get-the-Index-Values-From-forEach-Loop-in-JSTL)

このBaeldungの記事は、JSTL (JavaServer Pages Standard Tag Library) の `<c:forEach>` タグを使って、反復処理中に要素のインデックスを取得する方法を解説しています。

**主な内容:**

1.  **概要:**
    *   JSP でコードを簡素化するために JSTL が使用される。
    *   `<c:forEach>` タグは、配列、リスト、マップなどのコレクションを反復処理する。
    *   反復処理中に要素のインデックスにアクセスする必要がある場合がある。
2.  **シンプルな例の作成:**
    *   映画のリストを表示する簡単な Spring-MVC JSTL ウェブアプリケーションを作成する。
    *   `Movie` POJO (Plain Old Java Object) クラスと、映画データを処理する Spring コントローラーを作成。
    *   JSP ファイル (`jstlForEachDemo.jsp`) を作成し、`<c:forEach>` タグを使って映画データを HTML テーブルで表示する。
3.  **`varStatus` を使用したインデックスとカウントへのアクセス:**
    *   JSTL は、`forEach` ループ内の要素のインデックスを取得するための組み込みメカニズムを提供する。
    *   `varStatus` 属性を使用すると、反復処理に関するメタデータを提供するループステータス変数を定義できる。
    *   `theLoop.index` を使用してゼロベースのインデックスにアクセスする。
    *   `theLoop.count` を使用して、1 ベースのインデックスにアクセスする。
4.  **`varStatus` の他の便利なプロパティ:**
    *   `varStatus` は、`index` と `count` に加えて、他のプロパティも提供する。
    *   ループ内で最初または最後の要素かどうかを検出するために、`first` と `last` というブール値プロパティを使用できる。
    *   `first` と `last` プロパティを使用して、最初の行と最後の行に異なる背景色を設定する例を示す。
5.  **結論:**
    *   JSTL の `<c:forEach>` ループ内でインデックスにアクセスする方法について解説した。
    *   ロジックのためにゼロベースのインデックスが必要な場合でも、表示目的のために 1 ベースのカウントが必要な場合でも、JSTL はループを効果的に処理するための使いやすいソリューションを提供する。
    *   `varStatus` の `first` および `last` プロパティを使用して、`<c:forEach>` ループ内の最初と最後の反復処理を検出する方法を説明した。

記事は、JSTL の `<c:forEach>` タグ内で要素のインデックスにアクセスし、ループの状況（最初と最後など）を判断する方法を理解するための実践的なガイダンスを提供しています。

---
# Gatling Tests Monitoring | Baeldung

[View on Baeldung](https://feeds.feedblitz.com/~/916301819/0/baeldung~Gatling-Tests-Monitoring)

## Gatlingテストのモニタリングに関する要約

### 概要

この記事では、Gatlingを用いた負荷テスト実行時の適切なモニタリング設定方法について解説しています。REST APIとGatlingの両方を監視するために必要なツールを設定し、テスト実行のデモンストレーションを行い、Grafanaダッシュボードを用いて結果を読み解く方法を示しています。さらに、JVMスレッドやガベージコレクションなど、負荷テスト実行時に注視すべきメトリクスについても言及しています。

### 1. ツールと設定

*   **目的:** RESTアプリケーションのパフォーマンスを監視する。
*   **使用ツール:**
    *   **RESTアプリケーション:** メトリクスを公開するSpring Boot Actuatorを使用。
    *   **Prometheus:** RESTアプリケーションからメトリクスを収集し、時系列データとして保存。
    *   **InfluxDB:** Gatlingからのメトリクスを収集するための時系列データベース。
    *   **Grafana:** 結果をグラフで可視化し、データソース（Prometheus、InfluxDB）との統合が可能。
*   **設定:** Docker Composeを使用して、各ツールをコンテナ化し、ローカル環境で実行。
    *   **REST API:** 2つのエンドポイントを持つシンプルなSpring Boot MVCアプリケーション。1つは高速応答、もう1つはランダムな遅延を伴うスロー応答。
    *   **Prometheus:** メトリクスのスクレイピング設定を定義（prometheus.yml）。
    *   **Gatling:** Graphiteにメトリクスをエクスポートするように設定（gatling.conf）。InfluxDBがGatlingデータの保存先。
    *   **InfluxDB:** Gatlingがエクスポートしたデータを格納するためのデータベース。
    *   **Grafana:** PrometheusとInfluxDBをデータソースとして設定し、ダッシュボードで可視化。

### 2. Gatlingテストの実行とモニタリング

*   Docker Composeで全てのサービス（InfluxDB, Prometheus, Grafana, REST API）を起動。
*   Gatlingシミュレーションを実行。
*   Grafanaでモニタリングデータを確認。
    *   アプリケーションメトリクス: TPS（Transaction per Second）や応答遅延を可視化。
    *   Gatlingメトリクス: 応答コード、遅延などをクライアント側の視点から表示。

### 3. 結果の読み解きとチューニング

*   JVMのスレッドメトリクスから、エンドポイントごとのスレッド利用状況を把握。過剰なスレッド利用の可能性を特定。
*   ガベージコレクションのメトリクスに注目。GCの頻度、期間などを監視。
*   メトリクスに基づき、JVMのチューニングを実施し、パフォーマンス改善を図る。

### 4. まとめ

Gatlingによる負荷テスト実行時に、REST APIとGatlingを適切に監視するための設定と、Grafanaダッシュボードによる結果の可視化について解説しました。JVMスレッドやガベージコレクションなどの重要なメトリクスに注目し、パフォーマンス改善に役立てる方法を提示しています。
