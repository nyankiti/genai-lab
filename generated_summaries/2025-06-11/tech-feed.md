# Partial Keyframes • Josh W. Comeau

[View on Josh W Comeau's Blog](https://www.joshwcomeau.com/animation/partial-keyframes/)

## 部分的なキーフレームによるCSSアニメーションの活用： Josh W. Comeau

この記事は、CSSキーフレームアニメーションをより動的かつ柔軟にするためのテクニックを紹介しています。具体的には、`from`または`to`のどちらか一方だけを定義する「部分的なキーフレーム」を使用することで、アニメーションの開始値または終了値を要素の現在の状態から継承させる方法を解説しています。

**要点:**

*   **部分的なキーフレームの仕組み:** `from`を省略した場合、アニメーションは要素の現在の値を開始点として使用し、`to`を省略した場合は指定された値から要素の現在の値へとアニメーションします。
*   **メリット:**
    *   コードを簡潔にするだけでなく、要素のデフォルトの状態に依存するアニメーション（例：マウスオーバー時のボタンの透明度変化）を簡単に実現できます。
    *   複数のアニメーションを組み合わせることで、より複雑なエフェクトを作成できます。例えば、点滅するアニメーションにフェードインを組み合わせるなど。
    *   CSS変数と組み合わせることで、各要素で異なるアニメーションの動き（例：異なる振れ幅を持つボールの動き）を簡単に実現できます。
*   **応用例:**
    *   デフォルトの透明度を持っていない要素のフェードアウト。
    *   マウスオーバー時のボタンの透明度変化。
    *   他のキーフレームアニメーションで指定された値へのアニメーション。
    *   CSS変数を使用した、動的な値でのアニメーション。
*   **補足:**
    *   古いバージョンのSafariでは、複数のキーフレームが期待通りに動作しない場合がある（この問題は、要素をネストすることで回避可能）。
    *   CSS変数（`--amount`など）をキーフレーム内で使用することで、要素ごとに異なるアニメーションパラメータを制御できます。
*   **その他:** 著者は、CSSアニメーションに関する新しいコースを開発しており、関連情報への登録を呼びかけています。
---
# How Vercel's adapting SEO for LLMs and AI search - Vercel

[View on Vercel Blog](https://vercel.com/blog/how-were-adapting-seo-for-llms-and-ai-search)

## VercelがLLMとAI検索に対応するためのSEO戦略 - 要約

Vercelは、AIが検索方法を大きく変えつつある現状に対応するため、SEO戦略を再構築しています。キーワードやバックリンクだけでは十分ではなくなり、ChatGPTやGoogleのAI OverviewsのようなAIインターフェースが、ユーザーがリンクをクリックする前に直接質問に答えるようになっています。LLM（大規模言語モデル）がコンテンツの露出を左右する新たな層となり、コンテンツの見られ方が変化しています。

この変化は、従来のSEO（検索エンジン最適化）に代わる「LLM SEO」という新しいアプローチを必要としています。LLM SEOは、従来のSEOを補完するものであり、マーケター、コンテンツ戦略家、プロダクトチームにとって大きなチャンスです。

**なぜ検索が変わったのか？**

AIインターフェースは、多くの質問に直接答え、ユーザーはリンクをクリックする必要がなくなってきています。Vercelの例では、ChatGPTからの新規登録者が増加しており、AI検索がTallyの最大の獲得チャネルとなるなど、他の企業でも同様の変化が見られています。ただし、AI主導の結果が必ずしもトラフィックに繋がるとは限らず、GoogleのAI Overviewsはクリック数を減少させる可能性もあります。

**従来のSEOとLLM SEOのバランス**

従来のSEOとLLM SEOは異なるシステムに対応していますが、両方を無視することはできません。両方のシステムでコンテンツを見つけてもらうために、両方の戦略をサポートする必要があります。

*   **従来のSEO:** バックリンク、クロール可能なページ、キーワード、検索結果ページでのランキングなど。
*   **LLM SEO/AI SEO:** 埋め込みベースの関連性、自然言語クエリ、概念の明確さ、schema markup、RAG（Retrieval-Augmented Generation）インデックスでの表示など。

**LLM SEOの成功のために**

LLM SEOは、明確で構造化された、オリジナルで関連性の高いコンテンツを作成することを目指します。LLMはキーワードの繰り返しではなく、意味を解釈するため、コンテンツの質が重要です。

**LLMがコンテンツをどのように読み、処理するか**

AIシステムがどのようにコンテンツを解釈するかを理解することが重要です。多くのシステムはRAGを使用し、実行時に外部情報を取得します。そのため、コンテンツはクロール可能で、構造化され、解釈しやすい必要があります。LLMは、単語や概念間の関係を表す高次元の埋め込みを通じて、トレーニング中に学習した内容にも依存しています。

**LLMが評価する要素**

LLM SEOは、「答えになること」を追求します。概念を深く理解し、構造化し、引用を獲得し、常に最新の状態に保つことが重要です。具体的には、以下のような要素が重要です。

*   **フロンティアコンセプトを見つける:** 競合が少ないテーマで、専門家としての地位を確立する。
*   **決定的な情報源を公開する:** 表面的な内容ではなく、オリジナルなデータ、コード、専門家の引用などを盛り込む。
*   **機械のために構造化する:** 見出し、schema markup、セマンティック要素などを活用して、コンテンツの意図を明確にする。
*   **信頼できる引用を埋め込む:** コミュニティでの言及、バックリンク、インデックス可能なチャネル（Reddit、GitHubなど）を活用する。
*   **更新頻度を設定する:** 最新の情報を提供し、コンテンツを定期的に更新する。

**AIの影響を追跡する**

AIシステムでのコンテンツの可視性を測定することは、まだ発展途上の課題ですが、以下の要素を追跡することで、ある程度の指標を得ることができます。

*   **引用元:** Perplexity、Google AI Overviews、ChatGPTなどがソースを表示しているかを確認する。
*   **参照トラフィック:** ウェブアナリティクスツールを使用して、chat.openai.com、perplexity.aiなどからの訪問を追跡する。
*   **言及とリンク:** コミュニティフォーラム、ソーシャルメディア、ブログでの言及を監視する。
*   **インデックスカバレッジ:** Google Search ConsoleやBing Webmaster Toolsを使用して、インデックス登録と主要な概念のランキングを追跡する。

**結論**

LLM SEOには近道はありません。長期的な戦略と新しい思考が必要です。コンテンツの質を高め、明確な構造を構築し、AIモデルが理解しやすく、ユーザーに役立つコンテンツを作成することが重要です。

---
# Filter runtime logs for fatal function errors - Vercel

[View on Vercel Blog](https://vercel.com/changelog/filter-runtime-logs-for-fatal-function-errors)

## Vercelのランタイムログにおける致命的エラーのフィルタリング機能に関する要約

この記事は、Vercelプラットフォームのランタイムログにおいて、致命的な関数エラー（Node.jsのクラッシュなど）をフィルタリングできるようになったことを紹介しています。

**主なポイント:**

*   **機能:** ランタイムログのレベルフィルターで「Fatal」オプションを選択することで、致命的なエラーに該当するログエントリのみを表示できるようになりました。
*   **表示:** 致命的エラーが発生した場合、ログの右側のパネルで「Invocation Failed（呼び出し失敗）」と表示されます。
*   **目的:** この機能により、開発者は迅速に問題の原因を特定し、デバッグを効率的に行うことが可能になります。

記事では、実際に試してみるか、ランタイムログの詳細について学ぶように促しています。

---
# Kotlin for Server-Side Development: Community Content Roundup #2 | The Kotlin Blog

[View on JetBrains Blog (Kotlin)](https://blog.jetbrains.com/kotlin/2025/06/kotlin-for-server-side-development-community-content-roundup-2/)

## Kotlin for Server-Side Development: Community Content Roundup #2 の要約

この記事は、Kotlinを使ったサーバーサイド開発に関する最新のコミュニティコンテンツをまとめたものです。JetBrainsのKotlinブログで公開され、Kotlinコミュニティがサーバーサイド開発向けに提供している様々な情報（記事、動画、サンプルプロジェクト）を紹介しています。

**主な内容:**

*   **Spring Bootに関するヒントとテクニック:** Elena van Engelen-Maslovaによる、Spring Bootで関数をインジェクションする方法を紹介する記事。
*   **Ktor入門:** Rafał Maciakによる、Spring Bootに慣れた開発者がKtorを学ぶための比較解説記事。
*   **Spring for GraphQLとKotlinコルーチン:** Piotr Wolakによる、Spring for GraphQLとKotlinコルーチンを使ったリアクティブGraphQL API構築方法の動画。
*   **Kotlin + gRPC:** Lucas Fugisawaによる、KotlinでgRPCサービスを構築するための実践的なガイド。
    *   最初のサービスの構築
    *   Protobufスキーマ設計の拡張
    *   ネスト、構成、検証、イディオム的なビルダーDSL
    *   ストリーミング、デッドライン、構造化エラー処理
    *   ツール、CI/CD、アーキテクチャプラクティス
*   **Ktor Server入門:** Sunil Kumarによる、Ktorを使ったセキュアなREST API構築方法の初心者向け動画。JWT認証を含む。

**その他:**

*   Kotlinでバックエンドを開発し、知識を共有する場合は、ハッシュタグ `#KotlinServerSide` を使用して投稿することを推奨しています。
*   JetBrainsは、コミュニティコンテンツを定期的に確認し、ブログやSNSで紹介しています。
*   記事の最後では、Kotlinブログの更新を購読するための情報と、KMP (Kotlin Multiplatform)に関する質問への回答、KotlinConf 2025での発表内容、JetBrainsとSpringチームの戦略的パートナーシップ、KotlinとAzulによるランタイムパフォーマンス向上に関する取り組みも紹介しています。
