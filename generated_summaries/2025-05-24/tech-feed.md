# Vercel security roundup: improved bot defenses, DoS mitigations, and insights - Vercel

[View on Vercel Blog](https://vercel.com/blog/vercel-security-roundup-improved-bot-defenses-dos-mitigations-and-insights)

## Vercel セキュリティ最新情報：ボット防御強化、DoS対策、インサイト

Vercelは、2月以降、1480億件の悪意のあるリクエストを1億800万のユニークIPアドレスからブロックしました。このセキュリティは全てのデプロイメントに自動的に適用され、インシデント対応ではなく、開発に集中できるよう支援します。

**主な強化点:**

*   **WAFのパフォーマンスインサイト:** 悪意のあるリクエストが四半期比70%増の1480億件に達し、ユニークIPアドレス数は468%増の1億800万に急増。攻撃元の上位は米国、アイルランド、シンガポールなど。
*   **高度なボット防御:** 新しいBot Filterをパブリックベータ版としてリリース。ワンクリックで有効化でき、正当なボット（Googlebotなど）やcronジョブを妨害せずに、非ブラウザボットをブロック。
*   **DoS対策の高速化:** DoS攻撃対策インフラ「Protectd」を導入。毎秒約55万イベントを分析し、平均2.5秒、99パーセンタイル3.5秒でLayer 7攻撃を軽減。設定不要で全てのデプロイメントに効果。
*   **SDLCセキュリティガイド:** 新しいホワイトペーパー「Secure every step of a modern SDLC」で、計画からコーディング、デプロイ、モニタリングに至るまで、Vercelのセキュリティ機能がどのように適用されるかを解説し、コンプライアンスと安全なアプリケーション開発を支援。
*   **脆弱性管理とアカウントセキュリティ:** オープンソースフレームワークの脆弱性に対し、Vercelプラットフォームを強化。
    *   React RouterとRemixの脆弱性（CVE-2025-43864, CVE-2025-43865）：Vercel Firewallで対策、キャッシュ汚染によるDoS攻撃やXSS攻撃を防ぐ。
    *   React Routerの脆弱性（CVE-2025-31137）：プラットフォームアーキテクチャにより影響を回避。
    *   SAMLStormの脆弱性（CVE-2025-29774, CVE-2025-29775）：Vercel Firewallで対策、SAML認証バイパスのリスクを軽減。
    *   Next.jsミドルウェアの脆弱性（CVE-2025-29927, CVE-2025-30218）：CVE-2025-29927の影響はなし。CVE-2025-30218（軽微）を修正し、インフラプロバイダーに早期開示。
    *   多要素認証（MFA）：Google AuthenticatorやAuthyなどのTOTPアプリによる二要素認証を推奨。
*   **Firewallのユーザビリティ向上:** ルール作成の柔軟性、攻撃時の詳細制御、トラフィックパターンの可視性向上。
    *   検証済みボットとcronジョブはAttack Challenge Modeをバイパス。
    *   カスタムFirewallルールでOR演算子をサポート。
    *   プレビュードメイン向けにORシステムバイパスルールを拡張。
    *   FirewallダッシュボードにIPエンリッチメントを追加。

**今後の展望:**

*   RSA Conferenceでの議論：ソフトウェアサプライチェーンのセキュリティ、AIを活用したセキュリティチームの自動化、Vibeコーディングなどの新興プラクティスにおけるセキュリティ確保。
*   Vercel Ship（6月25日）：ライブデモ、技術討論、顧客事例紹介。

**採用情報:** CDN Security Engineer、Accounts Engineer、Security Product Manager、Security Operations Engineer、Security Automation Engineer、Security Researcherなどの職種を募集。

**その他:**

*   Vercel FirewallによるDDoSとボット対策に関するオンラインセッションを公開。
*   セキュリティページでデモへのサインアップやFirewallルールの追加が可能。

---
# Middleware insights now available in Vercel Observability - Vercel

[View on Vercel Blog](https://vercel.com/changelog/middleware-insights-now-available-in-vercel-observability)

Vercel Observability に、ミドルウェアに関する詳細な分析を提供する専用のビューが追加されました。この新しい機能により、開発者はミドルウェアの呼び出し回数やパフォーマンス指標を確認できるようになります。

Observability Plus を利用しているユーザーは、さらに高度なインサイトとツールを利用できます。具体的には、

*   リクエストパスごとの呼び出し分析
*   リダイレクトやリライトなど、ミドルウェアアクションのタイプ別の内訳
*   リライトターゲットと頻度の表示
*   クエリビルダーを使用したミドルウェア呼び出しのクエリ

などが可能になります。

---
# Faster CDN proxying to external origins - Vercel

[View on Vercel Blog](https://vercel.com/changelog/faster-cdn-proxying-to-external-origins)

## Vercel、CDNプロキシにおける外部オリジンへの接続を高速化

Vercelは、CDN（コンテンツデリバリーネットワーク）における外部バックエンドへの接続を最適化し、トラフィック量に関わらずレイテンシ（遅延）を低減しました。

**主な改善点:**

*   **低レイテンシ:** 接続の再利用とTLSセッションの再開を改善することで、一部地域では応答時間が最大60%短縮、平均15〜30%短縮されました。
*   **オリジン負荷の軽減:** 97%の接続再利用と、より効率的なTLSセッション再開により、新規ハンドシェイクの回数が大幅に削減されました。

これらの改善は、追加費用なしで全てのVercelデプロイメントで利用可能になっています。

---
# Rate limiting now available on Hobby, with higher included usage on Pro - Vercel

[View on Vercel Blog](https://vercel.com/changelog/rate-limiting-now-available-on-hobby-with-higher-included-usage-on-pro)

## Vercelのレート制限機能が進化：Hobbyプランにも対応、Proプランは利用量増加

この記事は、Vercelにおけるレート制限機能のアップデートについて簡潔に説明しています。要点は以下の通りです。

*   **Hobbyプランでも利用可能に:** レート制限機能が、これまでProプラン限定だったものが、Hobbyプランでも利用できるようになりました。
*   **無料利用枠の拡大:** 月間100万リクエストまでのレート制限リクエストが無料で利用できます。
*   **Hobbyプランの特典:** Hobbyチームは、プロジェクトごとに1つの無料レート制限ルールを利用できます（無料利用枠内）。
*   **自動適用:** これらの変更はすでに有効になっており、ユーザーのアカウントに自動的に適用されています。
*   **詳細情報へのリンク:** レート制限の設定方法や新しいレート制限ルールの作成に関する詳細情報へのリンクが提供されています。

要するに、Vercelはレート制限機能をより幅広いユーザーに提供し、アプリケーションの保護とトラフィック管理を強化しました。

---
# Arguments Prefixes in the JVM | Baeldung

[View on Baeldung](https://feeds.feedblitz.com/~/918836051/0/baeldung)

## JVMにおける引数プレフィックス

### 概要

本記事では、Java仮想マシン（JVM）の動作を詳細に制御するための引数プレフィックスについて解説しています。JVM引数は、アプリケーションのパフォーマンス向上、問題解決、実験的な機能の試用を可能にするコマンドラインオプションです。

### JVM引数とは

JVM引数は、JVMの動作を変更するための特別なコマンドラインオプションです。メモリ設定、パフォーマンスチューニング、デバッグとモニタリングの有効化、ガベージコレクション設定、および実験的機能の制御などを行います。

例えば、以下のコマンドのように使用できます。

```bash
java -Xmx512m -Denv=prod -verbose:gc -XX:+UseG1GC -jar App.jar
```

このコマンドでは、複数のプレフィックスが使用されています。各プレフィックスは、JVMに渡される設定の種類を示しています。

*   `-Xmx512m`: 最大ヒープサイズを512MBに設定（非標準オプション）
*   `-Denv=prod`: `env`というシステムプロパティを`prod`の値で定義（システムプロパティ）
*   `-verbose:gc`: ガベージコレクションのログを有効化（標準オプション）
*   `-XX:+UseG1GC`: G1ガベージコレクターを使用するようにJVMに指示（高度なオプション）

### 各引数プレフィックスの詳細

1.  **システムプロパティ（-D）**
    *   ファイルエンコーディング、ユーザーディレクトリ、JVMバージョンなど、JVM固有のパラメータを設定するために使用されます。
    *   `-D`引数を使用して、キーと値のペアを定義します。
    *   例: `java -Denv=prod -jar App.jar`
2.  **標準オプション（–）**
    *   JVMの基本的な動作を制御するための、ドキュメント化された設定です。すべてのJVM実装でサポートされています。
    *   `classpath`や`version`などのオプションがあります。
    *   例: `java -version`
3.  **非標準オプション（-X）**
    *   メモリやデバッグの動作を制御する、非標準のJVM機能にアクセスするために使用されます。JVM実装によって異なります。
    *   詳細なオプションは、`java -X`コマンドで確認できます。
    *   注意点: 実装に依存し、予告なく変更される可能性があるため、慎重に使用する必要があります。
4.  **高度なオプション（-XX）**
    *   低レベルかつ実験的な機能を有効にするために使用されます。
    *   ブールオプション（機能の有効/無効）と値オプション（カスタム値の設定）があります。
    *   安定性が低く、JVMのバージョンによって変更される可能性があります。
    *   例: `java -XX:+UseG1GC -XX:MaxGCPauseMillis=200 -jar App.jar` (G1ガベージコレクターの使用、GC一時停止時間の目標設定)

### JVM実行モード

JIT（Just-in-Time）コンパイルを制御し、Javaバイトコードをネイティブマシンコードにコンパイルして実行時に最適化するための実行モードについて説明します。

1.  **-Xint – インタプリタモードのみ**
    *   すべてのバイトコードを解釈し、JITコンパイルを無効にします。実行速度が大幅に低下します。
    *   JITの動作に関連する問題をデバッグし、JITコンパイルと純粋な解釈のパフォーマンスへの影響を比較するために役立ちます。
2.  **-Xcomp – コンパイルモードのみ**
    *   すべてのメソッドを最初の使用時にコンパイルし、ホットメソッドの識別を待ちません。
    *   起動は遅くなる可能性がありますが、長期的なパフォーマンス向上をもたらす可能性があります。
3.  **-Xmixed – デフォルトモード**
    *   コードを解釈し、ホットメソッドをJITコンパイラを使用してコンパイルします。起動時間と長期的なパフォーマンスのバランスを取ります。
    *   最近のバージョンのHotSpotではデフォルトでこのモードが使用されます。
4.  **-Xverify – 検証制御**
    *   バイトコード検証の実行タイミングを制御します。
    *   `-Xverify:all` (デフォルト): すべてのクラスをロード時に検証します。
    *   `-Xverify:none`: クラス検証をスキップします。起動時間をわずかに改善できますが、安全性が低下する可能性があります。

### まとめ

この記事では、さまざまなJVM引数プレフィックスについて説明しました。一般的なアプリケーションでは、`mixed`モードが最も効率的で安定した動作を提供します。適切なJVM引数を使用することで、アプリケーションのパフォーマンス、安定性、デバッグを向上させることができます。特定のJVM引数の設定は、アプリケーションの複雑さとパフォーマンス要件によって異なります。

---
# @Expose vs @SerializedName Annotations in Gson | Baeldung

[View on Baeldung](https://feeds.feedblitz.com/~/918836054/0/baeldung)

この記事は、GoogleのJavaライブラリであるGsonで使用される2つのアノテーション、`@Expose`と`@SerializedName`について解説しています。

**1. Gsonライブラリの概要と目的:**

*   Gsonは、JavaオブジェクトとJSONデータの相互変換を容易にするオープンソースライブラリです。
*   `@Expose`と`@SerializedName`は、Gsonを使ってJSONとの間でオブジェクトをシリアライズ/デシリアライズする際に、特定のフィールドの処理を制御するために使用されます。

**2. `@Expose`アノテーション:**

*   `@Expose`は、特定のフィールドをシリアライズおよびデシリアライズの対象から除外したり、含めたりする制御に使用します。
*   `GsonBuilder().excludeFieldsWithoutExposeAnnotation()`を使用して、`@Expose`が付与されていないフィールドを無視するようにGsonを設定できます。
*   `@Expose(serialize = true, deserialize = false)`のように、シリアライズとデシリアライズの動作を個別に制御することも可能です。

**3. `@SerializedName`アノテーション:**

*   `@SerializedName`は、Javaクラスのフィールド名と、JSONにおけるフィールド名の対応付けを変更するために使用します。
*   これにより、Javaクラスのフィールド名とJSONデータのフィールド名が異なる場合でも、正しく変換できます。
*   `alternate`属性を使用すると、複数の代替フィールド名を指定し、デシリアライズ時にいずれかの名前でフィールドをマッピングすることができます。

**4. `@Expose`と`@SerializedName`の違い:**

*   `@Expose`は、フィールドのシリアライズ/デシリアライズの対象を制御します（含める/除外する）。
*   `@SerializedName`は、JSONにおけるフィールド名を変更します。

**5. まとめ:**

*   `@Expose`と`@SerializedName`は、Gsonライブラリを使用してJavaオブジェクトとJSONデータを扱う際に、特定のフィールドのシリアライズとデシリアライズの動作を柔軟に制御するための重要なアノテーションです。
*   これらのアノテーションを適切に利用することで、より柔軟で効率的なJSON処理が可能になります。

---
# Loading Test Data from Files in JUnit Tests with Java Test Gadgets Test Data Factory | Baeldung

[View on Baeldung](https://feeds.feedblitz.com/~/918794885/0/baeldung)

## Baeldung記事「JUnitテストでファイルからテストデータを読み込む Java Test Gadgets Test Data Factory」の要約

この記事では、JUnitテストでテストデータをファイルから読み込む方法について解説しています。具体的には、Java Test Gadgets Test Data Factoryプラグインを活用し、テストデータのファイル管理を容易にする方法を紹介しています。

**1. 背景と課題:**

*   JUnitテストでテストデータを使用する場合、オブジェクトをテスト内でインスタンス化したり、テストデータファクトリクラスを使用したりする方法がありますが、場合によってはファイルにテストデータを保存し、テスト中に読み込む方が便利です。
*   従来のやり方では、ファイルのパス指定や例外処理、ファイル形式の変換など、定型的なコードが多く、テストコードが煩雑になるという課題がありました。

**2. Test Data Factoryの解決策:**

*   Test Data Factoryは、JUnit 4とJUnit 5に対応し、テストデータの読み込みを宣言的に行えるようにします。
*   **JUnit 4:** `TestDataFieldsRule` を使用し、 `@TestData` アノテーションでフィールドにファイルをインジェクションします。
*   **JUnit 5:** `@TestDataFactory` アノテーションでテストファイルのあるディレクトリを指定し、 `@TestData` アノテーションでフィールドにファイルをインジェクションします。テストメソッドの引数に `@TestData` を使用して、テストケースごとにデータを注入することも可能です。
*   **Lazy Loading:**  `Supplier` を使用して、必要なときにのみデータをロードするようにすることで、パフォーマンスを向上させます。
*   **Test Data Collection:**  複数のファイルセットを表現するために、インターフェースと `@TestDataCollection` アノテーションを使用できます。
*   **ファイル形式のサポート:**  デフォルトでは `.txt` と `.json` をサポートしており、`TestDataLoader` を使用して拡張できます。

**3. Test Data Factoryの利点:**

*   ファイルのパス指定や例外処理などの定型的なコードを削減し、テストコードを簡潔に保てます。
*   テストデータファイルの再利用、キャッシュ、および変更可能性を制御できます。
*   テストデータの管理とメンテナンスが容易になります。

**4. 実践的な活用:**

*   `.md` ファイルなどのカスタムファイル形式のサポート
*   データを共有するためのクラスレベルでのデータロード
*   不変なデータの場合、パフォーマンス向上のためのキャッシュ利用
*   テストケースに応じたデータの変更

**5. まとめ:**

Test Data Factoryを活用することで、テストデータのファイル管理を効率化し、よりクリーンで保守性の高いテストコードを記述できます。記事では、JUnit 4とJUnit 5での具体的な実装方法や、Lazy Loading、Test Data Collectionなどの高度な機能についても解説しています。
